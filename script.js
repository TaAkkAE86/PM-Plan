// Enhanced Translations with more features
const translations = {
    th: {
        pageTitle: "Ford PM PMHV Plan Dashboard",
        today: "‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ",
        week: "‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå",
        month: "‡πÄ‡∏î‡∏∑‡∏≠‡∏ô",
        language: "‡∏†‡∏≤‡∏©‡∏≤:",
        noSchedule: "üéâ ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏á‡∏≤‡∏ô PM ‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ",
        enjoyDay: "‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡∏Ç‡∏Å‡∏±‡∏ö‡∏ß‡∏±‡∏ô‡∏´‡∏¢‡∏∏‡∏î!",
        time: "‡πÄ‡∏ß‡∏•‡∏≤:",
        team: "‡∏ó‡∏µ‡∏°:",
        coach: "Process Coach:",
        status: "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞:",
        completed: "‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô",
        pending: "‡∏£‡∏≠‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£",
        done: "‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô",
        close: "‡∏õ‡∏¥‡∏î",
        notSpecified: "‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏",
        noScheduleDay: "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏á‡∏≤‡∏ô",
        resetAll: "‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ó‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
        confirmReset: "‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?",
        online: "‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß",
        offline: "‡∏≠‡∏≠‡∏ü‡πÑ‡∏•‡∏ô‡πå",
        // Enhanced translations
        totalTasks: "‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
        completedTasks: "‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß",
        pendingTasks: "‡∏£‡∏≠‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£",
        efficiency: "‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û",
        export: "‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•",
        settings: "‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤",
        darkMode: "‡πÇ‡∏´‡∏°‡∏î‡∏°‡∏∑‡∏î",
        fullscreen: "‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠",
        search: "‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤",
        filter: "‡∏Å‡∏£‡∏≠‡∏á",
        all: "‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
        byTeam: "‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡∏°",
        addNote: "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏",
        saveNote: "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏",
        cancel: "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å",
        enableNotifications: "‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô",
        autoRefresh: "‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)",
        timeFormat: "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏ß‡∏•‡∏≤",
        taskCompleted: "‡∏á‡∏≤‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô",
        taskCompletedDesc: "‡∏á‡∏≤‡∏ô {vehicle} ‡πÑ‡∏î‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô‡πÅ‡∏•‡πâ‡∏ß",
        allTasksCompleted: "‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô",
        allTasksCompletedDesc: "‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏î‡πâ‡∏ß‡∏¢! ‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô‡πÅ‡∏•‡πâ‡∏ß",
        dataExported: "‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡πâ‡∏ß",
        dataExportedDesc: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
        connectionRestored: "‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô‡πÅ‡∏•‡πâ‡∏ß",
        connectionLost: "‡∏Ç‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠",
        markComplete: "‡∏ô‡∏≥‡∏™‡πà‡∏á‡πÅ‡∏•‡πâ‡∏ß",
        loading: "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î...",
        selectDate: "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà:",
        firstAvailableDay: "‡∏ß‡∏±‡∏ô‡πÅ‡∏£‡∏Å‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏á‡∏≤‡∏ô",
        currentlyViewing: "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏π:",
        todayData: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ",
        closestData: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î",
        showingClosest: "‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î",
        closestAvailable: "(‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•)",
        // PIN Protection translations
        enterPIN: "‡πÉ‡∏™‡πà‡∏£‡∏´‡∏±‡∏™ PIN",
        resetWarning: "‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ó‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà PIN ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô:",
        incorrectPIN: "‡∏£‡∏´‡∏±‡∏™ PIN ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
        changePIN: "‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏´‡∏±‡∏™ PIN",
        pinAccepted: "‡∏£‡∏´‡∏±‡∏™ PIN ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
        accessGranted: "‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á",
        tryAgain: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á",
        enterCurrentPIN: "‡πÉ‡∏™‡πà PIN ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô:",
        enterNewPIN: "‡πÉ‡∏™‡πà PIN ‡πÉ‡∏´‡∏°‡πà:",
        confirmNewPIN: "‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô PIN ‡πÉ‡∏´‡∏°‡πà:",
        currentPINIncorrect: "PIN ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
        invalidPIN: "PIN ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
        pinMustBe4Digits: "PIN ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç 4 ‡∏´‡∏•‡∏±‡∏Å",
        pinMismatch: "PIN ‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô",
        pinsDoNotMatch: "PIN ‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô",
        pinChanged: "‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô PIN ‡πÅ‡∏•‡πâ‡∏ß",
        pinUpdatedSuccessfully: "‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏£‡∏´‡∏±‡∏™ PIN ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
        resetPINSecurity: "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ó",
        pinProtection: "PIN ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•",
        defaultPIN: "PIN ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô",
        resetComplete: "‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ó‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô",
        resetSuccessfully: "‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ó‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
        // Days and months
        sun: "‡∏≠‡∏≤", mon: "‡∏à", tue: "‡∏≠", wed: "‡∏û", thu: "‡∏û‡∏§", fri: "‡∏®", sat: "‡∏™",
        sunday: "‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå", monday: "‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå", tuesday: "‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£", wednesday: "‡∏û‡∏∏‡∏ò",
        thursday: "‡∏û‡∏§‡∏´‡∏±‡∏™‡∏ö‡∏î‡∏µ", friday: "‡∏®‡∏∏‡∏Å‡∏£‡πå", saturday: "‡πÄ‡∏™‡∏≤‡∏£‡πå",
        january: "‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°", february: "‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå", march: "‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°", april: "‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô",
        may: "‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°", june: "‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô", july: "‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°", august: "‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°",
        september: "‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô", october: "‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°", november: "‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô", december: "‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°"
    },
    en: {
        pageTitle: "Ford PM Schedule Dashboard",
        today: "Today", week: "Week", month: "Month", language: "Language:",
        noSchedule: "üéâ No PM Schedule Today", enjoyDay: "Enjoy your day off!",
        time: "Time:", team: "Team:", coach: "Process Coach:", status: "Status:",
        completed: "Completed", pending: "Pending", done: "Done", close: "Close",
        notSpecified: "Not specified", noScheduleDay: "No Schedule",
        resetAll: "Reset All", confirmReset: "Do you want to reset all status?",
        online: "Online", offline: "Offline",
        // Enhanced translations
        totalTasks: "Total Tasks", completedTasks: "Completed", pendingTasks: "Pending",
        efficiency: "Efficiency", export: "Export Data", settings: "Settings",
        darkMode: "Dark Mode", fullscreen: "Fullscreen", search: "Search",
        filter: "Filter", all: "All", byTeam: "By Team", addNote: "Add Note",
        saveNote: "Save Note", cancel: "Cancel", enableNotifications: "Enable Notifications",
        autoRefresh: "Auto Refresh (seconds)", timeFormat: "Time Format",
        taskCompleted: "Task Completed", taskCompletedDesc: "Task {vehicle} has been completed",
        allTasksCompleted: "All Tasks Completed", allTasksCompletedDesc: "Congratulations! All tasks for today are completed",
        dataExported: "Data Exported", dataExportedDesc: "Data has been exported successfully",
        connectionRestored: "Connection Restored", connectionLost: "Connection Lost",
        markComplete: "Mark Complete", loading: "Loading...",
        selectDate: "Select Date:", firstAvailableDay: "First Available Day",
        currentlyViewing: "Currently Viewing:", todayData: "Today's Data",
        closestData: "Closest Available Data", showingClosest: "Showing: Closest available data",
        closestAvailable: "(Closest available date with data)",
        // PIN Protection translations
        enterPIN: "Enter PIN",
        resetWarning: "This will reset all completed tasks. Enter PIN to confirm:",
        incorrectPIN: "Incorrect PIN",
        changePIN: "Change PIN",
        pinAccepted: "PIN Accepted",
        accessGranted: "Access granted",
        tryAgain: "Please try again",
        enterCurrentPIN: "Enter current PIN:",
        enterNewPIN: "Enter new PIN:",
        confirmNewPIN: "Confirm new PIN:",
        currentPINIncorrect: "Current PIN is incorrect",
        invalidPIN: "Invalid PIN",
        pinMustBe4Digits: "PIN must be 4 digits",
        pinMismatch: "PIN Mismatch",
        pinsDoNotMatch: "New PIN and confirmation do not match",
        pinChanged: "PIN Changed",
        pinUpdatedSuccessfully: "Reset PIN has been updated successfully",
        resetPINSecurity: "Reset PIN Security",
        pinProtection: "PIN protects reset function",
        defaultPIN: "Default PIN",
        resetComplete: "Reset Complete",
        resetSuccessfully: "reset successfully",
        // Days and months
        sun: "Sun", mon: "Mon", tue: "Tue", wed: "Wed", thu: "Thu", fri: "Fri", sat: "Sat",
        sunday: "Sunday", monday: "Monday", tuesday: "Tuesday", wednesday: "Wednesday",
        thursday: "Thursday", friday: "Friday", saturday: "Saturday",
        january: "January", february: "February", march: "March", april: "April",
        may: "May", june: "June", july: "July", august: "August",
        september: "September", october: "October", november: "November", december: "December"
    }
};

// Toast Notification System - Move to top for availability
function showToast(title, message, type = 'info', duration = 5000) {
    const container = document.getElementById('toastContainer');
    if (!container) {
        console.warn('Toast container not found');
        return;
    }
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    
    const icons = {
        success: '‚úÖ',
        error: '‚ùå',
        warning: '‚ö†Ô∏è',
        info: '‚ÑπÔ∏è'
    };
    
    toast.innerHTML = `
        <div class="toast-icon">${icons[type] || icons.info}</div>
        <div class="toast-content">
            <div class="toast-title">${title}</div>
            <div class="toast-message">${message}</div>
        </div>
        <div class="toast-close" onclick="this.parentElement.remove()">√ó</div>
    `;
    
    container.appendChild(toast);
    
    // Auto remove
    setTimeout(() => {
        if (toast.parentElement) {
            toast.style.transform = 'translateX(400px)';
            toast.style.opacity = '0';
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.remove();
                }
            }, 300);
        }
    }, duration);
}

// Enhanced Firebase Manager Class
class FirebaseManager {
    constructor() {
        this.isAvailable = false;
        this.retryCount = 0;
        this.maxRetries = 3;
        this.retryDelay = 1000;
        
        try {
            if (typeof firebase !== 'undefined' && firebase.firestore) {
                this.db = firebase.firestore();
                this.vehicleStatusRef = this.db.collection('vehicleStatus');
                this.notesRef = this.db.collection('vehicleNotes');
                this.analyticsRef = this.db.collection('analytics');
                this.isAvailable = true;
                console.log('Firebase Manager initialized successfully');
                
                // Setup offline persistence
                this.db.enablePersistence({ synchronizeTabs: true })
                    .catch(err => console.warn('Offline persistence failed:', err));
                    
            } else {
                throw new Error('Firebase not available');
            }
        } catch (error) {
            console.warn('Firebase initialization failed:', error);
            this.isAvailable = false;
        }
    }

    async withRetry(operation) {
        for (let i = 0; i <= this.maxRetries; i++) {
            try {
                return await operation();
            } catch (error) {
                if (i === this.maxRetries) throw error;
                await new Promise(resolve => setTimeout(resolve, this.retryDelay * Math.pow(2, i)));
            }
        }
    }

    async saveVehicleStatus(vehicleNumber, status, note = '') {
        if (!this.isAvailable) throw new Error('Firebase not available');
        
        return this.withRetry(async () => {
            const data = {
                status: status,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                vehicleNumber: vehicleNumber,
                completedBy: 'current_user',
                note: note
            };
            
            await this.vehicleStatusRef.doc(vehicleNumber).set(data);
            
            if (status === 'completed') {
                await this.saveAnalytics(vehicleNumber, 'task_completed');
            }
            
            console.log('Status saved successfully for:', vehicleNumber);
        });
    }

    async saveVehicleNote(vehicleNumber, note) {
        if (!this.isAvailable) throw new Error('Firebase not available');
        
        return this.withRetry(async () => {
            await this.notesRef.add({
                vehicleNumber: vehicleNumber,
                note: note,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                createdBy: 'current_user'
            });
            console.log('Note saved for:', vehicleNumber);
        });
    }

    async saveAnalytics(vehicleNumber, action) {
        if (!this.isAvailable) return;
        
        try {
            await this.analyticsRef.add({
                vehicleNumber: vehicleNumber,
                action: action,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                date: new Date().toISOString().split('T')[0],
                user: 'current_user'
            });
        } catch (error) {
            console.warn('Analytics save failed:', error);
        }
    }

    async loadAllVehicleStatus() {
        if (!this.isAvailable) return new Set();
        
        return this.withRetry(async () => {
            const snapshot = await this.vehicleStatusRef.where('status', '==', 'completed').get();
            const completedVehicles = new Set();
            
            snapshot.forEach(doc => {
                completedVehicles.add(doc.data().vehicleNumber);
            });
            
            console.log('Loaded completed vehicles:', completedVehicles.size);
            return completedVehicles;
        });
    }

    listenToStatusChanges(callback) {
        if (!this.isAvailable) return null;
        
        return this.vehicleStatusRef.where('status', '==', 'completed')
            .onSnapshot((snapshot) => {
                const completedVehicles = new Set();
                snapshot.forEach(doc => {
                    completedVehicles.add(doc.data().vehicleNumber);
                });
                callback(completedVehicles);
            }, (error) => {
                console.error('Error listening to changes:', error);
                showToast('Connection Error', 'Lost connection to server', 'error');
            });
    }

    async resetVehicleStatus(vehicleNumber) {
        if (!this.isAvailable) throw new Error('Firebase not available');
        
        return this.withRetry(async () => {
            await this.vehicleStatusRef.doc(vehicleNumber).delete();
            await this.saveAnalytics(vehicleNumber, 'task_reset');
            console.log('Reset status for:', vehicleNumber);
        });
    }

    async resetAllStatus() {
        if (!this.isAvailable) throw new Error('Firebase not available');
        
        return this.withRetry(async () => {
            const snapshot = await this.vehicleStatusRef.get();
            const batch = this.db.batch();
            
            snapshot.docs.forEach(doc => {
                batch.delete(doc.ref);
            });
            
            await batch.commit();
            await this.saveAnalytics('all', 'all_tasks_reset');
            console.log('All status reset successfully');
        });
    }

    async getAnalytics(dateRange = 7) {
        if (!this.isAvailable) return null;
        
        try {
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - dateRange);
            
            const snapshot = await this.analyticsRef
                .where('timestamp', '>=', startDate)
                .where('timestamp', '<=', endDate)
                .get();
                
            const analytics = [];
            snapshot.forEach(doc => {
                analytics.push(doc.data());
            });
            
            return analytics;
        } catch (error) {
            console.warn('Analytics load failed:', error);
            return null;
        }
    }
}

// Enhanced Notification Manager
class NotificationManager {
    constructor() {
        this.permission = 'Notification' in window ? Notification.permission : 'denied';
        this.enabled = localStorage.getItem('notificationsEnabled') === 'true';
    }

    async requestPermission() {
        if ('Notification' in window) {
            this.permission = await Notification.requestPermission();
            return this.permission === 'granted';
        }
        return false;
    }

    async show(title, options = {}) {
        if (!this.enabled || this.permission !== 'granted' || !('Notification' in window)) return;

        try {
            const notification = new Notification(title, {
                icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiByeD0iMTIiIGZpbGw9IiMwMDMzODciLz4KPGV4dCB4PSIzMiIgeT0iNDAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIyNCIgZm9udC13ZWlnaHQ9IjkwMCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiPkY8L3RleHQ+Cjwvc3ZnPgo=',
                badge: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiByeD0iMTIiIGZpbGw9IiMwMDMzODciLz4KPGV4dCB4PSIzMiIgeT0iNDAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIyNCIgZm9udC13ZWlnaHQ9IjkwMCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiPkY8L3RleHQ+Cjwvc3ZnPgo=',
                ...options
            });

            setTimeout(() => {
                try {
                    notification.close();
                } catch (e) {
                    console.warn('Could not close notification:', e);
                }
            }, 5000);
            
            return notification;
        } catch (error) {
            console.warn('Notification failed:', error);
        }
    }

    setEnabled(enabled) {
        this.enabled = enabled;
        localStorage.setItem('notificationsEnabled', enabled.toString());
    }
}

// Enhanced Global Variables
let completedVehicles = new Set();
let vehicleNotes = new Map();
let currentSelectedVehicle = null;
let currentView = 'today';
let currentLanguage = localStorage.getItem('language') || 'th';
let currentMonth = new Date(2025, 7);
let currentFilter = 'all';
let searchQuery = '';
let firebaseManager = null;
let notificationManager = null;
let unsubscribe = null;
let autoRefreshInterval = null;
let isDarkMode = localStorage.getItem('darkMode') === 'true';
let selectedDate = null; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà
let RESET_PIN = localStorage.getItem('resetPIN') || '1234'; // PIN ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
let settings = {
    autoRefresh: parseInt(localStorage.getItem('autoRefresh')) || 30,
    timeFormat: localStorage.getItem('timeFormat') || '12',
    notifications: localStorage.getItem('notificationsEnabled') === 'true'
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
function findCurrentOrClosestDate() {
    if (typeof scheduleData === 'undefined' || scheduleData.length === 0) {
        return null;
    }

    const today = new Date();
    const todayStr = `${String(today.getMonth() + 1).padStart(2, '0')}/${String(today.getDate()).padStart(2, '0')}/${today.getFullYear()}`;
    
    // ‡∏´‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Å‡πà‡∏≠‡∏ô
    let exactMatch = scheduleData.find(day => {
        const timeSlots = Object.keys(day).filter(key => 
            key !== 'Date' && key !== 'Day'
        );
        return day.Date === todayStr && timeSlots.length > 0;
    });

    if (exactMatch) {
        return exactMatch;
    }

    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô ‡πÉ‡∏´‡πâ‡∏´‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
    let closestDate = null;
    let minDifference = Infinity;
    
    const todayTime = today.getTime();

    scheduleData.forEach(day => {
        const timeSlots = Object.keys(day).filter(key => 
            key !== 'Date' && key !== 'Day'
        );
        
        if (timeSlots.length > 0) {
            try {
                const [month, dayNum, year] = day.Date.split('/').map(Number);
                const dayDate = new Date(year, month - 1, dayNum);
                const difference = Math.abs(dayDate.getTime() - todayTime);
                
                if (difference < minDifference) {
                    minDifference = difference;
                    closestDate = day;
                }
            } catch (error) {
                console.warn('Invalid date format:', day.Date);
            }
        }
    });

    return closestDate;
}

// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô requestPINForReset() ‡πÉ‡∏´‡∏°‡πà - ‡∏ã‡πà‡∏≠‡∏ô PIN ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
async function requestPINForReset() {
    return new Promise((resolve) => {
        const t = translations[currentLanguage];
        
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á modal ‡∏Ç‡∏≠ PIN
        const pinModal = document.createElement('div');
        pinModal.className = 'popup-overlay pin-overlay';
        pinModal.innerHTML = `
            <div class="popup-content pin-modal">
                <div class="popup-header">
                    <h3>üîí ${t.enterPIN}</h3>
                    <div class="popup-close pin-close">√ó</div>
                </div>
                <div class="pin-content">
                    <p>${t.resetWarning}</p>
                    <input type="password" id="pinInput" class="pin-input" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" maxlength="4" autocomplete="off">
                    <div class="pin-buttons">
                        <button class="btn btn-confirm" id="confirmPIN">
                            <span class="btn-icon">‚úì</span>
                            <span class="btn-text">${t.done}</span>
                        </button>
                        <button class="btn btn-cancel" id="cancelPIN">
                            <span class="btn-icon">‚úï</span>
                            <span class="btn-text">${t.cancel}</span>
                        </button>
                    </div>
                    <div class="pin-security-info">
                        <small>üîê ${t.pinProtection || 'PIN protects reset function'}</small>
                        <button class="pin-help-btn" id="pinHelpBtn" type="button">‚ùì</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(pinModal);
        pinModal.style.display = 'block';
        
        const pinInput = pinModal.querySelector('#pinInput');
        const confirmBtn = pinModal.querySelector('#confirmPIN');
        const cancelBtn = pinModal.querySelector('#cancelPIN');
        const closeBtn = pinModal.querySelector('.pin-close');
        const helpBtn = pinModal.querySelector('#pinHelpBtn');
        
        // Focus ‡πÑ‡∏õ‡∏ó‡∏µ‡πà input
        setTimeout(() => pinInput.focus(), 100);
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏¥‡∏î modal
        const closeModal = () => {
            if (pinModal.parentElement) {
                document.body.removeChild(pinModal);
            }
        };
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠ PIN (‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á PIN ‡∏ï‡∏£‡∏á‡πÜ)
        const showPinHelp = () => {
            const helpText = currentLanguage === 'th' ? 
                '‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏≤‡∏Å‡∏•‡∏∑‡∏° PIN ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô' :
                'Contact system administrator if you forgot PIN or check documentation';
            
            showToast('PIN Help', helpText, 'info', 5000);
        };
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö PIN
        const checkPIN = () => {
            const enteredPIN = pinInput.value.trim();
            if (enteredPIN === RESET_PIN) {
                closeModal();
                showToast(t.pinAccepted || 'PIN Accepted', t.accessGranted || 'Access granted', 'success', 2000);
                resolve(true);
            } else {
                pinInput.style.borderColor = '#e74c3c';
                pinInput.style.animation = 'shake 0.5s';
                pinInput.value = '';
                showToast(t.incorrectPIN, t.tryAgain || 'Please try again', 'error');
                setTimeout(() => {
                    pinInput.style.borderColor = '';
                    pinInput.style.animation = '';
                    pinInput.focus();
                }, 500);
            }
        };
        
        // Event listeners
        confirmBtn.addEventListener('click', checkPIN);
        
        cancelBtn.addEventListener('click', () => {
            closeModal();
            resolve(false);
        });
        
        closeBtn.addEventListener('click', () => {
            closeModal();
            resolve(false);
        });
        
        // Help button
        helpBtn.addEventListener('click', showPinHelp);
        
        // Enter key support
        pinInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                checkPIN();
            }
        });
        
        // Auto-submit when 4 digits entered
        pinInput.addEventListener('input', (e) => {
            // ‡πÉ‡∏´‡πâ‡∏õ‡πâ‡∏≠‡∏ô‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
            e.target.value = e.target.value.replace(/[^0-9]/g, '');
            
            if (e.target.value.length === 4) {
                setTimeout(checkPIN, 200); // Small delay for better UX
            }
        });
        
        // Cancel on overlay click
        pinModal.addEventListener('click', (e) => {
            if (e.target === pinModal) {
                closeModal();
                resolve(false);
            }
        });
        
        // Prevent modal from closing when clicking inside
        pinModal.querySelector('.popup-content').addEventListener('click', (e) => {
            e.stopPropagation();
        });
    });
}

// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô changePIN() ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á PIN ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
async function changePIN() {
    const t = translations[currentLanguage];
    
    return new Promise((resolve) => {
        const pinModal = document.createElement('div');
        pinModal.className = 'popup-overlay';
        pinModal.innerHTML = `
            <div class="popup-content pin-modal">
                <div class="popup-header">
                    <h3>üîë ${t.changePIN}</h3>
                    <div class="popup-close" onclick="this.closest('.popup-overlay').remove();">√ó</div>
                </div>
                <div class="pin-content">
                    <div class="pin-step">
                        <label>${t.enterCurrentPIN}</label>
                        <input type="password" id="currentPinInput" class="pin-input" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" maxlength="4" autocomplete="off">
                    </div>
                    <div class="pin-step">
                        <label>${t.enterNewPIN}</label>
                        <input type="password" id="newPinInput" class="pin-input" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" maxlength="4" autocomplete="off">
                    </div>
                    <div class="pin-step">
                        <label>${t.confirmNewPIN}</label>
                        <input type="password" id="confirmPinInput" class="pin-input" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" maxlength="4" autocomplete="off">
                    </div>
                    <div class="pin-buttons">
                        <button class="btn btn-confirm" id="savePIN">
                            <span class="btn-icon">üíæ</span>
                            <span class="btn-text">${t.saveNote || 'Save'}</span>
                        </button>
                        <button class="btn btn-cancel" id="cancelPINChange">
                            <span class="btn-icon">‚úï</span>
                            <span class="btn-text">${t.cancel}</span>
                        </button>
                    </div>
                    <div class="pin-security-note">
                        <small>‚ö†Ô∏è ${currentLanguage === 'th' ? '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏à‡∏î‡∏à‡∏≥ PIN ‡πÉ‡∏´‡∏°‡πà ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡πÑ‡∏î‡πâ' : 'Please remember your new PIN as it cannot be recovered'}</small>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(pinModal);
        pinModal.style.display = 'block';
        
        const currentPinInput = pinModal.querySelector('#currentPinInput');
        const newPinInput = pinModal.querySelector('#newPinInput');
        const confirmPinInput = pinModal.querySelector('#confirmPinInput');
        const savePIN = pinModal.querySelector('#savePIN');
        const cancelPINChange = pinModal.querySelector('#cancelPINChange');
        
        currentPinInput.focus();
        
        // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÉ‡∏´‡πâ‡∏õ‡πâ‡∏≠‡∏ô‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
        [currentPinInput, newPinInput, confirmPinInput].forEach(input => {
            input.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
            });
        });
        
        savePIN.onclick = () => {
            const currentPIN = currentPinInput.value;
            const newPIN = newPinInput.value;
            const confirmPIN = confirmPinInput.value;
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö PIN ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            if (currentPIN !== RESET_PIN) {
                showToast(t.incorrectPIN, t.currentPINIncorrect || 'Current PIN is incorrect', 'error');
                currentPinInput.focus();
                return;
            }
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö PIN ‡πÉ‡∏´‡∏°‡πà
            if (!/^\d{4}$/.test(newPIN)) {
                showToast(t.invalidPIN || 'Invalid PIN', t.pinMustBe4Digits || 'PIN must be 4 digits', 'error');
                newPinInput.focus();
                return;
            }
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô PIN
            if (newPIN !== confirmPIN) {
                showToast(t.pinMismatch || 'PIN Mismatch', t.pinsDoNotMatch || 'PINs do not match', 'error');
                confirmPinInput.focus();
                return;
            }
            
            // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å PIN ‡πÉ‡∏´‡∏°‡πà
            RESET_PIN = newPIN;
            localStorage.setItem('resetPIN', newPIN);
            
            // Log ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô PIN (‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å PIN ‡∏à‡∏£‡∏¥‡∏á)
            localStorage.setItem('lastPINChange', new Date().toISOString());
            localStorage.setItem('pinChangeCount', (parseInt(localStorage.getItem('pinChangeCount') || '0') + 1).toString());
            
            document.body.removeChild(pinModal);
            showToast(t.pinChanged || 'PIN Changed', t.pinUpdatedSuccessfully || 'Reset PIN has been updated successfully', 'success');
            resolve(true);
        };
        
        cancelPINChange.onclick = () => {
            document.body.removeChild(pinModal);
            resolve(false);
        };
    });
}

// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• PIN security ‡πÉ‡∏ô Settings
function updatePINSecurityInfo() {
    const pinInfo = document.querySelector('.pin-info');
    if (pinInfo) {
        const lastChange = localStorage.getItem('lastPINChange');
        const changeCount = localStorage.getItem('pinChangeCount') || '0';
        
        let infoText = currentLanguage === 'th' ? 
            `üîê PIN ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• | ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß: ${changeCount} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á` :
            `üîê PIN protects reset function | Changed: ${changeCount} times`;
        
        if (lastChange) {
            const changeDate = new Date(lastChange).toLocaleDateString();
            infoText += currentLanguage === 'th' ? ` | ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: ${changeDate}` : ` | Last: ${changeDate}`;
        }
        
        pinInfo.innerHTML = `<small>${infoText}</small>`;
    }
}


// Enhanced Loading System
function showLoadingOverlay(show) {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        if (show) {
            overlay.classList.add('show');
        } else {
            setTimeout(() => overlay.classList.remove('show'), 500);
        }
    }
}

// Enhanced Connection Status
function updateConnectionStatus(isOnline) {
    const statusElement = document.getElementById('connectionStatus');
    const t = translations[currentLanguage];
    
    if (statusElement) {
        const statusIcon = statusElement.querySelector('.status-icon');
        const statusText = statusElement.querySelector('.status-text');
        
        if (isOnline) {
            statusElement.className = 'connection-status online';
            if (statusIcon) statusIcon.textContent = '‚óè';
            if (statusText) statusText.textContent = t.online;
        } else {
            statusElement.className = 'connection-status offline';
            if (statusIcon) statusIcon.textContent = '‚óè';
            if (statusText) statusText.textContent = t.offline;
        }
    }
}

// Enhanced Statistics System
function updateStatistics() {
    const t = translations[currentLanguage];
    
    // Get current schedule for statistics
    const currentScheduleVehicles = getCurrentScheduleData();
    const totalTasks = currentScheduleVehicles.length;
    
    // ‡∏ô‡∏±‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏ñ‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏•‡∏∞‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ
    const completedInCurrentSchedule = currentScheduleVehicles.filter(vehicleNumber => 
        completedVehicles.has(vehicleNumber)
    ).length;
    
    const pending = totalTasks - completedInCurrentSchedule;
    const efficiency = totalTasks > 0 ? Math.round((completedInCurrentSchedule / totalTasks) * 100) : 0;
    
    // Update statistics display with safe element checking
    const totalTasksEl = document.getElementById('totalTasks');
    const completedTasksEl = document.getElementById('completedTasks');
    const pendingTasksEl = document.getElementById('pendingTasks');
    const efficiencyEl = document.getElementById('efficiency');
    
    if (totalTasksEl) animateNumber(totalTasksEl, totalTasks);
    if (completedTasksEl) animateNumber(completedTasksEl, completedInCurrentSchedule);
    if (pendingTasksEl) animateNumber(pendingTasksEl, pending);
    if (efficiencyEl) animateNumber(efficiencyEl, efficiency, '%');
    
    // Update labels
    const totalTasksLabel = document.getElementById('totalTasksLabel');
    const completedTasksLabel = document.getElementById('completedTasksLabel');
    const pendingTasksLabel = document.getElementById('pendingTasksLabel');
    const efficiencyLabel = document.getElementById('efficiencyLabel');
    
    if (totalTasksLabel) totalTasksLabel.textContent = t.totalTasks;
    if (completedTasksLabel) completedTasksLabel.textContent = t.completedTasks;
    if (pendingTasksLabel) pendingTasksLabel.textContent = t.pendingTasks;
    if (efficiencyLabel) efficiencyLabel.textContent = t.efficiency;
    
    // Update progress bar
    updateProgressBar(efficiency);
    
    // Update schedule stats
    updateScheduleStats();
    
    // Check if all tasks completed ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
    if (totalTasks > 0 && completedInCurrentSchedule === totalTasks && notificationManager) {
        notificationManager.show(t.allTasksCompleted, {
            body: t.allTasksCompletedDesc,
            tag: 'all-completed'
        });
        showToast(t.allTasksCompleted, t.allTasksCompletedDesc, 'success');
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏á‡∏≤‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
function getCurrentScheduleData() {
    if (typeof scheduleData === 'undefined') {
        console.warn('scheduleData not available');
        return [];
    }
    
    let currentSchedule;
    
    if (selectedDate && selectedDate !== 'auto') {
        // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏â‡∏û‡∏≤‡∏∞
        currentSchedule = scheduleData.find(day => day.Date === selectedDate);
    } else {
        // ‡∏´‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
        currentSchedule = findCurrentOrClosestDate();
    }
    
    if (!currentSchedule) return [];
    
    const timeSlots = Object.keys(currentSchedule).filter(key => 
        key !== 'Date' && key !== 'Day'
    );
    return timeSlots.map(slot => currentSchedule[slot]);
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
function getDetailedStatistics() {
    const currentData = getCurrentScheduleData();
    const totalTasks = currentData.length;
    
    // ‡∏ô‡∏±‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏ñ‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏•‡∏∞‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ
    const completedInCurrentSchedule = currentData.filter(vehicleNumber => 
        completedVehicles.has(vehicleNumber)
    );
    
    const pendingInCurrentSchedule = currentData.filter(vehicleNumber => 
        !completedVehicles.has(vehicleNumber)
    );
    
    return {
        total: totalTasks,
        completed: completedInCurrentSchedule.length,
        pending: pendingInCurrentSchedule.length,
        completedList: completedInCurrentSchedule,
        pendingList: pendingInCurrentSchedule,
        efficiency: totalTasks > 0 ? Math.round((completedInCurrentSchedule.length / totalTasks) * 100) : 0
    };
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
function updateScheduleStats() {
    const statsElement = document.getElementById('scheduleStats');
    if (!statsElement) return;
    
    const stats = getDetailedStatistics();
    const currentOrClosest = findCurrentOrClosestDate();
    
    if (currentOrClosest && stats.total > 0) {
        const t = translations[currentLanguage];
        const today = new Date();
        const todayStr = `${String(today.getMonth() + 1).padStart(2, '0')}/${String(today.getDate()).padStart(2, '0')}/${today.getFullYear()}`;
        const isToday = currentOrClosest.Date === todayStr;
        
        const dateLabel = isToday ? 
            (currentLanguage === 'th' ? '‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ' : 'Today') : 
            currentOrClosest.Date;
            
        statsElement.innerHTML = `
            üìä ${dateLabel}: ${stats.completed}/${stats.total} ${t.completed} (${stats.efficiency}%)
        `;
        statsElement.style.display = 'inline-block';
    } else {
        statsElement.style.display = 'none';
    }
}

function animateNumber(element, target, suffix = '') {
    if (!element) return;
    
    const current = parseInt(element.textContent) || 0;
    if (current === target) return;
    
    const increment = target > current ? 1 : -1;
    const step = Math.max(1, Math.abs(target - current) / 20);
    
    let currentNumber = current;
    const timer = setInterval(() => {
        currentNumber += increment * step;
        if ((increment > 0 && currentNumber >= target) || 
            (increment < 0 && currentNumber <= target)) {
            currentNumber = target;
            clearInterval(timer);
        }
        element.textContent = Math.round(currentNumber) + suffix;
    }, 50);
}

function updateProgressBar(percentage) {
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    
    if (progressFill) {
        progressFill.style.width = percentage + '%';
    }
    
    if (progressText) {
        const t = translations[currentLanguage];
        progressText.textContent = `${percentage}% ${t.completed}`;
    }
}

// Enhanced LocalStorage functions
function saveCompletedVehicles() {
    try {
        localStorage.setItem('completedVehicles', JSON.stringify([...completedVehicles]));
        localStorage.setItem('lastSaved', new Date().toISOString());
    } catch (error) {
        console.error('Failed to save to localStorage:', error);
    }
}

function loadCompletedVehicles() {
    try {
        const saved = localStorage.getItem('completedVehicles');
        if (saved) {
            completedVehicles = new Set(JSON.parse(saved));
        }
    } catch (error) {
        console.error('Failed to load from localStorage:', error);
        completedVehicles = new Set();
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Date Selector
function populateDateSelector() {
    const dateSelect = document.getElementById('dateSelect');
    if (!dateSelect || typeof scheduleData === 'undefined') return;
    
    // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå options ‡πÄ‡∏î‡∏¥‡∏°
    dateSelect.innerHTML = '';
    
    // ‡∏´‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
    const currentOrClosest = findCurrentOrClosestDate();
    
    // ‡πÄ‡∏û‡∏¥‡πà‡∏° option ‡πÅ‡∏£‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô/‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
    const autoOption = document.createElement('option');
    autoOption.value = 'auto';
    
    if (currentOrClosest) {
        const today = new Date();
        const todayStr = `${String(today.getMonth() + 1).padStart(2, '0')}/${String(today.getDate()).padStart(2, '0')}/${today.getFullYear()}`;
        const isToday = currentOrClosest.Date === todayStr;
        
        if (isToday) {
            autoOption.textContent = currentLanguage === 'th' ? 
                `‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ (${currentOrClosest.Date})` : 
                `Today (${currentOrClosest.Date})`;
        } else {
            autoOption.textContent = currentLanguage === 'th' ? 
                `‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î (${currentOrClosest.Date})` : 
                `Closest Date (${currentOrClosest.Date})`;
        }
    } else {
        autoOption.textContent = translations[currentLanguage].firstAvailableDay;
    }
    
    dateSelect.appendChild(autoOption);
    
    // ‡πÄ‡∏û‡∏¥‡πà‡∏° options ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    scheduleData.forEach(day => {
        const timeSlots = Object.keys(day).filter(key => 
            key !== 'Date' && key !== 'Day'
        );
        
        if (timeSlots.length > 0) {
            const option = document.createElement('option');
            option.value = day.Date;
            option.textContent = `${day.Date} (${day.Day})`;
            dateSelect.appendChild(option);
        }
    });
    
    // ‡πÄ‡∏û‡∏¥‡πà‡∏° event listener
    dateSelect.addEventListener('change', function() {
        selectedDate = this.value;
        loadSchedule();
        updateStatistics();
    });
}

// Initialize the enhanced app
document.addEventListener('DOMContentLoaded', async function() {
    showLoadingOverlay(true);
    
    try {
        // Initialize Dark Mode
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
            const darkModeBtn = document.getElementById('darkModeBtn');
            if (darkModeBtn) darkModeBtn.textContent = '‚òÄÔ∏è';
        }
        
        // Initialize Notification Manager
        notificationManager = new NotificationManager();
        
        updateConnectionStatus(false);
        
        // Initialize Firebase Manager with enhanced error handling
        try {
            firebaseManager = new FirebaseManager();
            
            if (firebaseManager.isAvailable) {
                completedVehicles = await firebaseManager.loadAllVehicleStatus();
                
                unsubscribe = firebaseManager.listenToStatusChanges((newCompletedVehicles) => {
                    const previousCount = completedVehicles.size;
                    completedVehicles = newCompletedVehicles;
                    const currentCount = completedVehicles.size;
                    
                    // Show notification for new completions
                    if (currentCount > previousCount && notificationManager && notificationManager.enabled) {
                        const t = translations[currentLanguage];
                        const lastCompleted = [...completedVehicles].pop();
                        notificationManager.show(t.taskCompleted, {
                            body: t.taskCompletedDesc.replace('{vehicle}', lastCompleted || ''),
                            tag: 'task-completed'
                        });
                    }
                    
                    updateStatistics();
                    loadSchedule();
                });
                
                updateConnectionStatus(true);
                showToast(
                    translations[currentLanguage].connectionRestored,
                    'Connected to Ford PM System',
                    'success'
                );
                
            } else {
                throw new Error('Firebase not available');
            }
        } catch (error) {
            console.warn('Using LocalStorage fallback:', error);
            firebaseManager = null;
            loadCompletedVehicles();
            updateConnectionStatus(false);
            showToast(
                translations[currentLanguage].connectionLost,
                'Using offline mode',
                'warning'
            );
        }

        // Setup all event listeners
        setupEventListeners();
        setupAdvancedFeatures();
        
        // Initialize UI
        updateLanguage();
        updateCurrentDate();
        populateDateSelector(); // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ
        updateStatistics();
        loadSchedule();
        
        // Setup auto-refresh
        setupAutoRefresh();
        
        // Setup settings from localStorage
        applySettings();
        
    } catch (error) {
        console.error('App initialization failed:', error);
        showToast('Initialization Error', 'Failed to start the application', 'error');
    } finally {
        showLoadingOverlay(false);
    }
});

// Enhanced Event Listeners Setup
function setupEventListeners() {
    // View buttons
    document.querySelectorAll('.view-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            currentView = this.getAttribute('data-view');
            loadSchedule();
            
            // Analytics
            if (firebaseManager && firebaseManager.isAvailable) {
                firebaseManager.saveAnalytics('navigation', `view_${currentView}`).catch(console.warn);
            }
        });
    });

    // Language toggle with enhanced UX
    const langSwitch = document.getElementById('langSwitch');
    if (langSwitch) {
        langSwitch.addEventListener('click', function() {
            this.classList.toggle('en');
            currentLanguage = currentLanguage === 'th' ? 'en' : 'th';
            localStorage.setItem('language', currentLanguage);
            updateLanguage();
            populateDateSelector(); // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï date selector ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏†‡∏≤‡∏©‡∏≤
            updateConnectionStatus(firebaseManager && firebaseManager.isAvailable);
            showToast('Language Changed', `Switched to ${currentLanguage.toUpperCase()}`, 'info', 2000);
        });
    }

    // Enhanced header buttons
    const settingsBtn = document.getElementById('settingsBtn');
    if (settingsBtn) {
        settingsBtn.addEventListener('click', showSettings);
    }

    const fullscreenBtn = document.getElementById('fullscreenBtn');
    if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', toggleFullscreen);
    }

    const darkModeBtn = document.getElementById('darkModeBtn');
    if (darkModeBtn) {
        darkModeBtn.addEventListener('click', toggleDarkMode);
    }

    // Search functionality
    const searchInput = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    
    if (searchInput) {
        searchInput.addEventListener('input', handleSearch);
        searchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') handleSearch();
        });
    }
    
    if (searchBtn) {
        searchBtn.addEventListener('click', handleSearch);
    }

    // Filter buttons
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            currentFilter = this.getAttribute('data-filter');
            loadSchedule();
        });
    });

    // Setup popup events
    setupPopupEvents();
    
    // Setup keyboard shortcuts
    setupKeyboardShortcuts();
}

// Advanced Features Setup
function setupAdvancedFeatures() {
    // Setup PWA install prompt
    let deferredPrompt;
    window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;
        showInstallPrompt();
    });

    // Setup online/offline detection
    window.addEventListener('online', () => {
        updateConnectionStatus(true);
        showToast(
            translations[currentLanguage].connectionRestored,
            'Back online',
            'success',
            3000
        );
    });

    window.addEventListener('offline', () => {
        updateConnectionStatus(false);
        showToast(
            translations[currentLanguage].connectionLost,
            'Working offline',
            'warning',
            3000
        );
    });

    // Setup visibility change
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        } else {
            setupAutoRefresh();
            loadSchedule();
        }
    });
}

function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
            switch(e.key) {
                case '1':
                    switchView('today');
                    break;
                case '2':
                    switchView('week');
                    break;
                case '3':
                    switchView('month');
                    break;
                case 'r':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        loadSchedule();
                        showToast('Refreshed', 'Data refreshed', 'info', 2000);
                    }
                    break;
                case 'f':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        const searchInput = document.getElementById('searchInput');
                        if (searchInput) searchInput.focus();
                    }
                    break;
                case 'Escape':
                    closeAllModals();
                    break;
            }
        }
    });
}

function switchView(view) {
    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
    const viewBtn = document.querySelector(`[data-view="${view}"]`);
    if (viewBtn) viewBtn.classList.add('active');
    currentView = view;
    loadSchedule();
}

function closeAllModals() {
    closePopup();
    closeSettings();
    closeNote();
}

// Settings System
function showSettings() {
    const overlay = document.getElementById('settingsOverlay');
    if (overlay) {
        overlay.style.display = 'block';
        
        const notificationToggle = document.getElementById('notificationToggle');
        const autoRefresh = document.getElementById('autoRefresh');
        const timeFormat = document.getElementById('timeFormat');
        const changePINBtn = document.getElementById('changePINBtn');
        
        if (notificationToggle) notificationToggle.checked = settings.notifications;
        if (autoRefresh) autoRefresh.value = settings.autoRefresh;
        if (timeFormat) timeFormat.value = settings.timeFormat;
        
        // Update PIN security info
        updatePINSecurityInfo();
        
        // Setup PIN change button
        if (changePINBtn && !changePINBtn.hasEventListener) {
            changePINBtn.hasEventListener = true;
            changePINBtn.onclick = changePIN;
        }
        
        if (notificationToggle) {
            notificationToggle.onchange = (e) => {
                settings.notifications = e.target.checked;
                localStorage.setItem('notificationsEnabled', e.target.checked);
                if (notificationManager) {
                    notificationManager.setEnabled(e.target.checked);
                    if (e.target.checked) {
                        notificationManager.requestPermission();
                    }
                }
            };
        }
        
        if (autoRefresh) {
            autoRefresh.onchange = (e) => {
                settings.autoRefresh = parseInt(e.target.value);
                localStorage.setItem('autoRefresh', e.target.value);
                setupAutoRefresh();
            };
        }
        
        if (timeFormat) {
            timeFormat.onchange = (e) => {
                settings.timeFormat = e.target.value;
                localStorage.setItem('timeFormat', e.target.value);
                loadSchedule();
            };
        }
    }
}


function closeSettings() {
    const overlay = document.getElementById('settingsOverlay');
    if (overlay) {
        overlay.style.display = 'none';
    }
}

function applySettings() {
    if (notificationManager) {
        notificationManager.setEnabled(settings.notifications);
    }
    setupAutoRefresh();
}

function setupAutoRefresh() {
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
    }
    
    if (settings.autoRefresh > 0 && !document.hidden) {
        autoRefreshInterval = setInterval(() => {
            loadSchedule();
            updateStatistics();
        }, settings.autoRefresh * 1000);
    }
}

// Enhanced Dark Mode
function toggleDarkMode() {
    isDarkMode = !isDarkMode;
    document.body.classList.toggle('dark-mode');
    localStorage.setItem('darkMode', isDarkMode);
    
    const darkModeBtn = document.getElementById('darkModeBtn');
    if (darkModeBtn) {
        darkModeBtn.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô';
    }
    
    showToast(
        'Theme Changed', 
        `Switched to ${isDarkMode ? 'Dark' : 'Light'} mode`, 
        'info', 
        2000
    );
}

// Enhanced Fullscreen
function toggleFullscreen() {
    try {
        if (!document.fullscreenElement) {
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().then(() => {
                    showToast('Fullscreen', 'Entered fullscreen mode', 'info', 2000);
                }).catch(err => {
                    console.warn('Fullscreen failed:', err);
                    showToast('Fullscreen', 'Fullscreen not supported', 'warning', 2000);
                });
            }
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen().then(() => {
                    showToast('Fullscreen', 'Exited fullscreen mode', 'info', 2000);
                }).catch(console.warn);
            }
        }
    } catch (error) {
        console.warn('Fullscreen error:', error);
        showToast('Fullscreen', 'Fullscreen operation failed', 'error', 2000);
    }
}

// Search and Filter System
function handleSearch() {
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchQuery = searchInput.value.toLowerCase().trim();
        loadSchedule();
        
        if (searchQuery) {
            showToast('Search', `Searching for: ${searchQuery}`, 'info', 2000);
        }
    }
}

function filterScheduleData(scheduleList) {
    if (!scheduleList || scheduleList.length === 0) return scheduleList;
    
    return scheduleList.filter(item => {
        if (searchQuery) {
            const vehicleNumber = item.vehicleNumber || '';
            const details = (typeof pmDetails !== 'undefined' && pmDetails[vehicleNumber]) ? pmDetails[vehicleNumber] : {};
            const teamName = details.team || '';
            const coachName = details.coach || '';
            
            const searchText = `${vehicleNumber} ${teamName} ${coachName}`.toLowerCase();
            if (!searchText.includes(searchQuery)) {
                return false;
            }
        }
        
        if (currentFilter === 'completed') {
            return completedVehicles.has(item.vehicleNumber);
        } else if (currentFilter === 'pending') {
            return !completedVehicles.has(item.vehicleNumber);
        }
        
        return true;
    });
}

// Enhanced Data Export System
async function exportData() {
    try {
        showLoadingOverlay(true);
        
        const t = translations[currentLanguage];
        const currentData = getCurrentScheduleData();
        const totalTasks = currentData.length;
        
        // ‡∏ô‡∏±‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏ñ‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏•‡∏∞‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ
        const completedInCurrentSchedule = currentData.filter(vehicleNumber => 
            completedVehicles.has(vehicleNumber)
        ).length;
        
        const exportDataObj = {
            timestamp: new Date().toISOString(),
            currentView: currentView,
            selectedDate: selectedDate,
            currentScheduleInfo: {
                date: selectedDate || 'auto',
                totalVehicles: totalTasks,
                completedVehicles: completedInCurrentSchedule,
                vehicleList: currentData
            },
            statistics: {
                total: totalTasks,
                completed: completedInCurrentSchedule,
                pending: totalTasks - completedInCurrentSchedule,
                efficiency: totalTasks > 0 ? 
                    Math.round((completedInCurrentSchedule / totalTasks) * 100) : 0
            },
            scheduleData: typeof scheduleData !== 'undefined' ? scheduleData : [],
            allCompletedVehicles: [...completedVehicles],
            pmDetails: typeof pmDetails !== 'undefined' ? pmDetails : {}
        };
        
        const blob = new Blob([JSON.stringify(exportDataObj, null, 2)], 
            { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `ford-pm-schedule-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        if (firebaseManager && firebaseManager.isAvailable) {
            await firebaseManager.saveAnalytics('system', 'data_exported');
        }
        
        showToast(t.dataExported, t.dataExportedDesc, 'success');
        
    } catch (error) {
        console.error('Export failed:', error);
        showToast('Export Failed', 'Failed to export data', 'error');
    } finally {
        showLoadingOverlay(false);
    }
}

// Language Update
function updateLanguage() {
    const t = translations[currentLanguage];
    
    const elements = {
        'pageTitle': t.pageTitle,
        'btnToday': t.today,
        'btnWeek': t.week,
        'btnMonth': t.month,
        'langLabel': t.language,
        'resetBtn': t.resetAll,
        'exportBtn': t.export,
        'btnDone': t.markComplete,
        'btnNote': t.addNote,
        'btnClose': t.close,
        'settingsTitle': t.settings,
        'noteTitle': t.addNote,
        'notificationLabel': t.enableNotifications,
        'autoRefreshLabel': t.autoRefresh,
        'timeFormatLabel': t.timeFormat,
        'filterAll': t.all,
        'filterCompleted': t.completed,
        'filterPending': t.pending,
        'filterTeam': t.byTeam,
        'dateSelectLabel': t.selectDate,
        'resetPINLabel': t.resetPINSecurity,
        'changePINText': t.changePIN,
        'pinProtectionText': t.pinProtection
    };
    
    Object.entries(elements).forEach(([id, text]) => {
        const element = document.getElementById(id);
        if (element) {
            const btnText = element.querySelector('.btn-text');
            if (btnText) {
                btnText.textContent = text;
            } else {
                element.textContent = text;
            }
        }
    });
    
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.placeholder = `${t.search}...`;
    }
    
    updateCurrentDate();
    updateStatistics();
    loadSchedule();
}

function updateCurrentDate() {
    const now = new Date();
    const dateElement = document.getElementById('currentDate');
    
    if (dateElement) {
        let dateStr;
        try {
            if (currentLanguage === 'th') {
                dateStr = now.toLocaleDateString('th-TH', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    weekday: 'long'
                });
            } else {
                dateStr = now.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    weekday: 'long'
                });
            }
        } catch (error) {
            dateStr = now.toDateString();
        }
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        const currentOrClosest = findCurrentOrClosestDate();
        if (currentOrClosest) {
            const todayStr = `${String(now.getMonth() + 1).padStart(2, '0')}/${String(now.getDate()).padStart(2, '0')}/${now.getFullYear()}`;
            const isToday = currentOrClosest.Date === todayStr;
            
            if (!isToday) {
                const statusText = currentLanguage === 'th' ? 
                    ` | ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ${currentOrClosest.Date}` : 
                    ` | Showing: ${currentOrClosest.Date}`;
                dateStr += statusText;
            }
        }
        
        dateElement.textContent = dateStr;
    }
}

// Schedule Loading
function loadSchedule() {
    const container = document.getElementById('scheduleContainer');
    if (!container) return;
    
    container.classList.add('fadeIn');
    
    switch(currentView) {
        case 'today':
            loadTodaySchedule(container);
            break;
        case 'week':
            loadWeekSchedule(container);
            break;
        case 'month':
            loadMonthSchedule(container);
            break;
    }
}

// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô loadTodaySchedule ‡πÉ‡∏´‡∏°‡πà
function loadTodaySchedule(container) {
    if (typeof scheduleData === 'undefined') {
        container.innerHTML = `
            <div class="no-schedule">
                <h2>‚ö†Ô∏è Data Not Available</h2>
                <p>Schedule data is not loaded</p>
            </div>
        `;
        return;
    }

    let todaySchedule;
    
    if (selectedDate && selectedDate !== 'auto') {
        // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏â‡∏û‡∏≤‡∏∞
        todaySchedule = scheduleData.find(day => day.Date === selectedDate);
    } else {
        // ‡∏´‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
        todaySchedule = findCurrentOrClosestDate();
    }
    
    if (!todaySchedule) {
        const t = translations[currentLanguage];
        container.innerHTML = `
            <div class="no-schedule">
                <h2>${t.noSchedule}</h2>
                <p>${t.enjoyDay}</p>
            </div>
        `;
        return;
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const today = new Date();
    const todayStr = `${String(today.getMonth() + 1).padStart(2, '0')}/${String(today.getDate()).padStart(2, '0')}/${today.getFullYear()}`;
    const isToday = todaySchedule.Date === todayStr;

    // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏π
    const dateDisplay = document.createElement('div');
    dateDisplay.className = 'current-viewing-date';
    
    const t = translations[currentLanguage];
    let dateDisplayHTML = '';
    
    if (isToday) {
        dateDisplay.classList.add('today-highlight');
        dateDisplayHTML = `<h3>üìÖ ${t.currentlyViewing} ${todaySchedule.Date} - ${todaySchedule.Day} (${currentLanguage === 'th' ? '‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ' : 'Today'})</h3>`;
    } else {
        dateDisplayHTML = `
            <h3>üìÖ ${t.currentlyViewing} ${todaySchedule.Date} - ${todaySchedule.Day}</h3>
            <div class="date-note">${t.closestAvailable}</div>
        `;
    }
    
    dateDisplay.innerHTML = dateDisplayHTML;
    
    const scheduleGrid = document.createElement('div');
    scheduleGrid.className = 'schedule-grid';

    const timeSlots = Object.keys(todaySchedule).filter(key => 
        key !== 'Date' && key !== 'Day'
    );

    const scheduleItems = timeSlots.map(slot => ({
        timeSlot: slot,
        vehicleNumber: todaySchedule[slot]
    }));

    const filteredItems = filterScheduleData(scheduleItems);

    if (filteredItems.length === 0 && (searchQuery || currentFilter !== 'all')) {
        container.innerHTML = '';
        container.appendChild(dateDisplay);
        const noResults = document.createElement('div');
        noResults.className = 'no-schedule';
        noResults.innerHTML = `
            <h2>üîç No Results Found</h2>
            <p>Try adjusting your search or filter criteria</p>
        `;
        container.appendChild(noResults);
        return;
    }

    filteredItems.forEach(item => {
        const timeSlotDiv = createTimeSlotCard(item.timeSlot, item.vehicleNumber);
        scheduleGrid.appendChild(timeSlotDiv);
    });

    container.innerHTML = '';
    container.appendChild(dateDisplay);
    container.appendChild(scheduleGrid);
}

// Time Slot Card Creation
function createTimeSlotCard(timeSlot, vehicleNumber) {
    const timeSlotDiv = document.createElement('div');
    timeSlotDiv.className = 'time-slot slideIn';

    const timeLabel = document.createElement('div');
    timeLabel.className = 'time-label';
    timeLabel.textContent = formatTime(timeSlot);

    const vehicleCard = document.createElement('div');
    vehicleCard.className = 'vehicle-card';
    vehicleCard.onclick = () => showVehicleDetails(vehicleNumber, timeSlot);

    if (completedVehicles.has(vehicleNumber)) {
        vehicleCard.classList.add('completed');
    }

    const vehicleNumberDiv = document.createElement('div');
    vehicleNumberDiv.className = 'vehicle-number';
    vehicleNumberDiv.textContent = vehicleNumber;

    const teamDiv = document.createElement('div');
    teamDiv.className = 'vehicle-team';
    const details = (typeof pmDetails !== 'undefined' && pmDetails[vehicleNumber]) ? pmDetails[vehicleNumber] : {};
    teamDiv.textContent = details.team || 'N/A';

    const statusBadge = document.createElement('div');
    statusBadge.className = 'status-badge';
    const t = translations[currentLanguage];
    statusBadge.textContent = completedVehicles.has(vehicleNumber) ? t.completed : t.pending;

    vehicleCard.appendChild(vehicleNumberDiv);
    vehicleCard.appendChild(teamDiv);
    vehicleCard.appendChild(statusBadge);

    timeSlotDiv.appendChild(timeLabel);
    timeSlotDiv.appendChild(vehicleCard);

    return timeSlotDiv;
}

function formatTime(timeSlot) {
    if (settings.timeFormat === '12') {
        return timeSlot.replace(/(\d{1,2}):(\d{2})/g, (match, hour, minute) => {
            const h = parseInt(hour);
            const period = h >= 12 ? 'PM' : 'AM';
            const displayHour = h === 0 ? 12 : h > 12 ? h - 12 : h;
            return `${displayHour}:${minute} ${period}`;
        });
    }
    return timeSlot;
}

// Week Schedule Loading  
function loadWeekSchedule(container) {
    if (typeof scheduleData === 'undefined') {
        container.innerHTML = `
            <div class="no-schedule">
                <h2>‚ö†Ô∏è Data Not Available</h2>
                <p>Schedule data is not loaded</p>
            </div>
        `;
        return;
    }

    const weekView = document.createElement('div');
    weekView.className = 'week-view';

    const t = translations[currentLanguage];
    const dayNames = currentLanguage === 'th' 
        ? [t.sun, t.mon, t.tue, t.wed, t.thu, t.fri, t.sat]
        : [t.sun, t.mon, t.tue, t.wed, t.thu, t.fri, t.sat];

    const startDate = new Date(2025, 7, 1);

    for (let i = 0; i < 7; i++) {
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + i);
        
        const dateStr = `${String(currentDate.getMonth() + 1).padStart(2, '0')}/${String(currentDate.getDate()).padStart(2, '0')}/${currentDate.getFullYear()}`;
        const dayData = scheduleData.find(day => day.Date === dateStr);
        
        const dayDiv = document.createElement('div');
        dayDiv.className = 'week-day';
        
        if (isToday(currentDate)) {
            dayDiv.classList.add('today');
        }
        
        const dayHeader = document.createElement('div');
        dayHeader.className = 'week-day-header';
        
        const dayName = dayNames[currentDate.getDay()];
        const dayNumber = currentDate.getDate();
        const monthName = currentLanguage === 'th' 
            ? getThaiMonthName(currentDate.getMonth())
            : getEnglishMonthName(currentDate.getMonth());
        
        dayHeader.innerHTML = `
            <div style="font-size: 1em; margin-bottom: 5px;">${dayName}</div>
            <div style="font-size: 0.9em; opacity: 0.8;">${dayNumber} ${monthName}</div>
        `;

        dayDiv.appendChild(dayHeader);

        if (dayData) {
            const timeSlots = Object.keys(dayData).filter(key => 
                key !== 'Date' && key !== 'Day'
            );

            const scheduleItems = timeSlots.map(slot => ({
                timeSlot: slot,
                vehicleNumber: dayData[slot]
            }));

            const filteredItems = filterScheduleData(scheduleItems);

            filteredItems.forEach(item => {
                const vehicleCard = createCompactVehicleCard(item.vehicleNumber, item.timeSlot);
                dayDiv.appendChild(vehicleCard);
            });
        } else {
            const noScheduleDiv = document.createElement('div');
            noScheduleDiv.style.cssText = `
                text-align: center;
                color: #bdc3c7;
                font-style: italic;
                margin-top: 20px;
                padding: 20px;
            `;
            noScheduleDiv.textContent = t.noScheduleDay;
            dayDiv.appendChild(noScheduleDiv);
        }

        weekView.appendChild(dayDiv);
    }

    container.innerHTML = '';
    container.appendChild(weekView);
}

function isToday(date) {
    const today = new Date();
    return date.toDateString() === today.toDateString();
}

// Month Schedule Loading
function loadMonthSchedule(container) {
    if (typeof scheduleData === 'undefined') {
        container.innerHTML = `
            <div class="no-schedule">
                <h2>‚ö†Ô∏è Data Not Available</h2>
                <p>Schedule data is not loaded</p>
            </div>
        `;
        return;
    }

    const monthView = document.createElement('div');
    monthView.className = 'month-view';

    const monthHeader = document.createElement('div');
    monthHeader.className = 'month-header';

    const monthNav = document.createElement('div');
    monthNav.className = 'month-nav';

    const prevBtn = document.createElement('button');
    prevBtn.className = 'nav-btn';
    prevBtn.innerHTML = '‚Äπ Previous';
    prevBtn.onclick = () => {
        currentMonth.setMonth(currentMonth.getMonth() - 1);
        loadMonthSchedule(container);
    };

    const nextBtn = document.createElement('button');
    nextBtn.className = 'nav-btn';
    nextBtn.innerHTML = 'Next ‚Ä∫';
    nextBtn.onclick = () => {
        currentMonth.setMonth(currentMonth.getMonth() + 1);
        loadMonthSchedule(container);
    };

    const monthTitle = document.createElement('h2');
    const t = translations[currentLanguage];
    const monthNames = currentLanguage === 'th' 
        ? [t.january, t.february, t.march, t.april, t.may, t.june, 
           t.july, t.august, t.september, t.october, t.november, t.december]
        : ['January', 'February', 'March', 'April', 'May', 'June',
           'July', 'August', 'September', 'October', 'November', 'December'];
    
    monthTitle.textContent = `${monthNames[currentMonth.getMonth()]} ${currentMonth.getFullYear()}`;

    monthNav.appendChild(prevBtn);
    monthNav.appendChild(nextBtn);
    monthHeader.appendChild(monthTitle);
    monthHeader.appendChild(monthNav);

    const monthGrid = document.createElement('div');
    monthGrid.className = 'month-grid';

    const dayNames = currentLanguage === 'th' 
        ? [t.sun, t.mon, t.tue, t.wed, t.thu, t.fri, t.sat]
        : [t.sun, t.mon, t.tue, t.wed, t.thu, t.fri, t.sat];

    dayNames.forEach(day => {
        const dayHeader = document.createElement('div');
        dayHeader.className = 'month-day-header';
        dayHeader.textContent = day;
        monthGrid.appendChild(dayHeader);
    });

    const firstDay = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), 1);
    const startDate = new Date(firstDay);
    startDate.setDate(startDate.getDate() - firstDay.getDay());

    for (let i = 0; i < 42; i++) {
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + i);

        const dayDiv = document.createElement('div');
        dayDiv.className = 'month-day';

        const dayNumber = document.createElement('div');
        dayNumber.className = 'month-day-number';
        dayNumber.textContent = currentDate.getDate();

        if (currentDate.getMonth() !== currentMonth.getMonth()) {
            dayDiv.classList.add('other-month');
        }

        if (isToday(currentDate)) {
            dayDiv.classList.add('today');
        }

        dayDiv.appendChild(dayNumber);

        const dateStr = `${String(currentDate.getMonth() + 1).padStart(2, '0')}/${String(currentDate.getDate()).padStart(2, '0')}/${currentDate.getFullYear()}`;
        const dayData = scheduleData.find(day => day.Date === dateStr);

        if (dayData && currentDate.getMonth() === currentMonth.getMonth()) {
            const timeSlots = Object.keys(dayData).filter(key => 
                key !== 'Date' && key !== 'Day'
            );

            const scheduleItems = timeSlots.map(slot => ({
                timeSlot: slot,
                vehicleNumber: dayData[slot]
            }));

            const filteredItems = filterScheduleData(scheduleItems);

            filteredItems.slice(0, 3).forEach(item => {
                const vehicleCard = createCompactVehicleCard(item.vehicleNumber, item.timeSlot);
                dayDiv.appendChild(vehicleCard);
            });

            if (filteredItems.length > 3) {
                const moreDiv = document.createElement('div');
                moreDiv.style.cssText = 'font-size: 0.7em; color: #7f8c8d; text-align: center; margin-top: 2px;';
                moreDiv.textContent = `+${filteredItems.length - 3} more`;
                dayDiv.appendChild(moreDiv);
            }
        }

        monthGrid.appendChild(dayDiv);
    }

    monthView.appendChild(monthHeader);
    monthView.appendChild(monthGrid);

    container.innerHTML = '';
    container.appendChild(monthView);
}

// Helper functions
function getThaiMonthName(monthIndex) {
    const monthNames = [
        '‡∏°.‡∏Ñ.', '‡∏Å.‡∏û.', '‡∏°‡∏µ.‡∏Ñ.', '‡πÄ‡∏°.‡∏¢.', '‡∏û.‡∏Ñ.', '‡∏°‡∏¥.‡∏¢.',
        '‡∏Å.‡∏Ñ.', '‡∏™.‡∏Ñ.', '‡∏Å.‡∏¢.', '‡∏ï.‡∏Ñ.', '‡∏û.‡∏¢.', '‡∏ò.‡∏Ñ.'
    ];
    return monthNames[monthIndex];
}

function getEnglishMonthName(monthIndex) {
    const monthNames = [
        'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    return monthNames[monthIndex];
}

// Compact Vehicle Card
function createCompactVehicleCard(vehicleNumber, timeSlot) {
    const vehicleCard = document.createElement('div');
    vehicleCard.className = 'vehicle-card compact';
    vehicleCard.onclick = () => showVehicleDetails(vehicleNumber, timeSlot);

    if (completedVehicles.has(vehicleNumber)) {
        vehicleCard.classList.add('completed');
    }

    const vehicleNumberDiv = document.createElement('div');
    vehicleNumberDiv.className = 'vehicle-number';
    vehicleNumberDiv.textContent = vehicleNumber;

    const vehicleTimeDiv = document.createElement('div');
    vehicleTimeDiv.className = 'vehicle-time';
    vehicleTimeDiv.textContent = formatTime(timeSlot);

    const statusBadge = document.createElement('div');
    statusBadge.className = 'status-badge';
    const t = translations[currentLanguage];
    statusBadge.textContent = completedVehicles.has(vehicleNumber) ? t.completed : t.pending;

    vehicleCard.appendChild(vehicleNumberDiv);
    vehicleCard.appendChild(vehicleTimeDiv);
    vehicleCard.appendChild(statusBadge);

    return vehicleCard;
}

// Vehicle Details Popup
function showVehicleDetails(vehicleNumber, timeSlot) {
    currentSelectedVehicle = { number: vehicleNumber, timeSlot: timeSlot };
    
    const details = (typeof pmDetails !== 'undefined' && pmDetails[vehicleNumber]) ? pmDetails[vehicleNumber] : {};
    if (!details || Object.keys(details).length === 0) {
        showToast('Error', `No data found for vehicle ${vehicleNumber}`, 'error');
        return;
    }

    const t = translations[currentLanguage];

    const popupVehicleNumber = document.getElementById('popupVehicleNumber');
    if (popupVehicleNumber) {
        popupVehicleNumber.textContent = vehicleNumber;
    }
    
    const popupDetails = document.getElementById('popupDetails');
    if (popupDetails) {
        const isCompleted = completedVehicles.has(vehicleNumber);
        
        popupDetails.innerHTML = `
            <div class="detail-row">
                <span class="detail-label">üïê ${t.time}</span>
                <span class="detail-value">${formatTime(timeSlot)}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">üë• ${t.team}</span>
                <span class="detail-value">${details.team || t.notSpecified}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">üë®‚Äçüíº ${t.coach}</span>
                <span class="detail-value">${details.coach || t.notSpecified}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">üìä ${t.status}</span>
                <span class="detail-value ${isCompleted ? 'text-success' : 'text-warning'}">
                    ${isCompleted ? '‚úÖ ' + t.completed : '‚è≥ ' + t.pending}
                </span>
            </div>
        `;
    }

    showActionHistory(vehicleNumber);

    const doneBtn = document.getElementById('btnDone');
    if (doneBtn) {
        doneBtn.style.display = completedVehicles.has(vehicleNumber) ? 'none' : 'flex';
    }

    const popupOverlay = document.getElementById('popupOverlay');
    if (popupOverlay) {
        popupOverlay.style.display = 'block';
    }
}

function showActionHistory(vehicleNumber) {
    const historyContainer = document.getElementById('actionHistory');
    if (!historyContainer) return;

    const history = [
        { action: 'Created', time: '2 hours ago', icon: 'üìù' },
        { action: 'Assigned', time: '1 hour ago', icon: 'üë§' }
    ];

    if (completedVehicles.has(vehicleNumber)) {
        history.push({ action: 'Completed', time: 'Just now', icon: '‚úÖ' });
    }

    historyContainer.innerHTML = `
        <h4>Recent Activity</h4>
        ${history.map(item => `
            <div class="history-item">
                <div class="history-icon">${item.icon}</div>
                <div class="history-content">
                    <div class="history-action">${item.action}</div>
                    <div class="history-time">${item.time}</div>
                </div>
            </div>
        `).join('')}
    `;
}

// Popup Event Handlers
function setupPopupEvents() {
    const btnDone = document.getElementById('btnDone');
    if (btnDone) {
        btnDone.addEventListener('click', async function() {
            if (currentSelectedVehicle) {
                await markVehicleCompleted(currentSelectedVehicle.number);
                closePopup();
            }
        });
    }

    const btnNote = document.getElementById('btnNote');
    if (btnNote) {
        btnNote.addEventListener('click', function() {
            showNoteModal();
        });
    }

    const btnClose = document.getElementById('btnClose');
    if (btnClose) {
        btnClose.addEventListener('click', closePopup);
    }

    const popupOverlay = document.getElementById('popupOverlay');
    if (popupOverlay) {
        popupOverlay.addEventListener('click', function(e) {
            if (e.target === this) closePopup();
        });
    }
}

// Note System
function showNoteModal() {
    const overlay = document.getElementById('noteOverlay');
    if (overlay) {
        overlay.style.display = 'block';
        const textarea = document.getElementById('noteText');
        if (textarea) {
            textarea.focus();
            const existingNote = vehicleNotes.get(currentSelectedVehicle?.number) || '';
            textarea.value = existingNote;
        }
    }
}

function closeNote() {
    const overlay = document.getElementById('noteOverlay');
    if (overlay) {
        overlay.style.display = 'none';
        const textarea = document.getElementById('noteText');
        if (textarea) textarea.value = '';
    }
}

async function saveNote() {
    const textarea = document.getElementById('noteText');
    const note = textarea?.value.trim();
    
    if (!note || !currentSelectedVehicle) {
        showToast('Error', 'Please enter a note', 'error');
        return;
    }

    try {
        if (firebaseManager && firebaseManager.isAvailable) {
            await firebaseManager.saveVehicleNote(currentSelectedVehicle.number, note);
        }
        
        vehicleNotes.set(currentSelectedVehicle.number, note);
        try {
            localStorage.setItem('vehicleNotes', JSON.stringify([...vehicleNotes]));
        } catch (e) {
            console.warn('Failed to save note to localStorage:', e);
        }
        
        showToast('Note Saved', 'Note has been saved successfully', 'success');
        closeNote();
        
    } catch (error) {
        console.error('Failed to save note:', error);
        showToast('Error', 'Failed to save note', 'error');
    }
}

// Vehicle Completion
async function markVehicleCompleted(vehicleNumber) {
    try {
        completedVehicles.add(vehicleNumber);
        
        const t = translations[currentLanguage];
        
        if (firebaseManager && firebaseManager.isAvailable) {
            await firebaseManager.saveVehicleStatus(vehicleNumber, 'completed');
        } else {
            saveCompletedVehicles();
        }
        
        if (notificationManager && notificationManager.enabled) {
            notificationManager.show(t.taskCompleted, {
                body: t.taskCompletedDesc.replace('{vehicle}', vehicleNumber),
                tag: `completed-${vehicleNumber}`
            });
        }
        
        showToast(t.taskCompleted, `Vehicle ${vehicleNumber} marked as complete`, 'success');
        
        updateStatistics();
        loadSchedule();
        
    } catch (error) {
        console.error('Error marking vehicle completed:', error);
        showToast('Error', 'Failed to mark vehicle as completed', 'error');
        saveCompletedVehicles();
    }
}

// Reset Functions
async function resetVehicleStatus(vehicleNumber) {
    try {
        completedVehicles.delete(vehicleNumber);
        
        if (firebaseManager && firebaseManager.isAvailable) {
            await firebaseManager.resetVehicleStatus(vehicleNumber);
        } else {
            saveCompletedVehicles();
        }
        
        updateStatistics();
        loadSchedule();
        showToast('Reset', `Vehicle ${vehicleNumber} status reset`, 'info');
        
    } catch (error) {
        console.error('Error resetting vehicle status:', error);
        saveCompletedVehicles();
    }
}

// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô resetAllStatus ‡πÄ‡∏î‡∏¥‡∏°
async function resetAllStatus() {
    const t = translations[currentLanguage];
    
    try {
        // ‡∏Ç‡∏≠ PIN ‡∏Å‡πà‡∏≠‡∏ô
        const pinConfirmed = await requestPINForReset();
        if (!pinConfirmed) {
            console.log('Reset cancelled by user');
            return;
        }
        
        // ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
        if (!confirm(t.confirmReset)) {
            console.log('Reset cancelled at confirmation');
            return;
        }

        showLoadingOverlay(true);
        
        // ‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡πà‡∏≠‡∏ô‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ó
        const statsBeforeReset = getDetailedStatistics();
        
        completedVehicles.clear();
        
        if (firebaseManager && firebaseManager.isAvailable) {
            await firebaseManager.resetAllStatus();
        } else {
            saveCompletedVehicles();
        }
        
        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å log ‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ó
        const resetLog = {
            timestamp: new Date().toISOString(),
            type: 'complete_reset',
            beforeReset: statsBeforeReset,
            user: 'authorized_user'
        };
        
        try {
            const logs = JSON.parse(localStorage.getItem('resetLogs') || '[]');
            logs.push(resetLog);
            if (logs.length > 50) logs.splice(0, logs.length - 50); // ‡πÄ‡∏Å‡πá‡∏ö‡πÅ‡∏Ñ‡πà 50 log ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            localStorage.setItem('resetLogs', JSON.stringify(logs));
            localStorage.setItem('lastCompleteReset', new Date().toISOString());
        } catch (e) {
            console.warn('Failed to save reset log:', e);
        }
        
        console.log('Complete reset performed:', resetLog);
        
        updateStatistics();
        loadSchedule();
        showToast(
            t.resetComplete || 'Reset Complete', 
            `${statsBeforeReset.completed} ${t.completedTasks} ${t.resetSuccessfully || 'reset successfully'}`, 
            'success',
            5000
        );
        
    } catch (error) {
        console.error('Error resetting all status:', error);
        showToast('Error', 'Failed to reset all status', 'error');
        
        // Fallback to localStorage
        try {
            saveCompletedVehicles();
        } catch (e) {
            console.error('Fallback save failed:', e);
        }
    } finally {
        showLoadingOverlay(false);
    }
}

// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ event listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏° reset
function setupEventListeners() {
    // View buttons
    document.querySelectorAll('.view-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            currentView = this.getAttribute('data-view');
            loadSchedule();
            
            // Analytics
            if (firebaseManager && firebaseManager.isAvailable) {
                firebaseManager.saveAnalytics('navigation', `view_${currentView}`).catch(console.warn);
            }
        });
    });

    // Reset button - ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà
    const resetBtn = document.getElementById('resetBtn');
    if (resetBtn) {
        resetBtn.addEventListener('click', async function(e) {
            e.preventDefault();
            console.log('Reset button clicked');
            await resetAllStatus();
        });
    }

    // Language toggle with enhanced UX
    const langSwitch = document.getElementById('langSwitch');
    if (langSwitch) {
        langSwitch.addEventListener('click', function() {
            this.classList.toggle('en');
            currentLanguage = currentLanguage === 'th' ? 'en' : 'th';
            localStorage.setItem('language', currentLanguage);
            updateLanguage();
            populateDateSelector();
            updateConnectionStatus(firebaseManager && firebaseManager.isAvailable);
            showToast('Language Changed', `Switched to ${currentLanguage.toUpperCase()}`, 'info', 2000);
        });
    }

    // Enhanced header buttons
    const settingsBtn = document.getElementById('settingsBtn');
    if (settingsBtn) {
        settingsBtn.addEventListener('click', showSettings);
    }

    const fullscreenBtn = document.getElementById('fullscreenBtn');
    if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', toggleFullscreen);
    }

    const darkModeBtn = document.getElementById('darkModeBtn');
    if (darkModeBtn) {
        darkModeBtn.addEventListener('click', toggleDarkMode);
    }

    // Search functionality
    const searchInput = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    
    if (searchInput) {
        searchInput.addEventListener('input', handleSearch);
        searchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') handleSearch();
        });
    }
    
    if (searchBtn) {
        searchBtn.addEventListener('click', handleSearch);
    }

    // Filter buttons
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            currentFilter = this.getAttribute('data-filter');
            loadSchedule();
        });
    });

    // Setup popup events
    setupPopupEvents();
    
    // Setup keyboard shortcuts
    setupKeyboardShortcuts();
}

// Utility Functions
function closePopup() {
    const overlay = document.getElementById('popupOverlay');
    if (overlay) {
        overlay.style.display = 'none';
    }
    currentSelectedVehicle = null;
}

function showInstallPrompt() {
    showToast(
        'Install App', 
        'Add Ford PM Dashboard to your home screen for quick access', 
        'info', 
        8000
    );
}

// Cleanup
window.addEventListener('beforeunload', () => {
    if (unsubscribe) unsubscribe();
    if (autoRefreshInterval) clearInterval(autoRefreshInterval);
});

// Export functions for global access
window.resetAllStatus = resetAllStatus;
window.resetVehicleStatus = resetVehicleStatus;
window.exportData = exportData;
window.closeSettings = closeSettings;
window.closeNote = closeNote;
window.saveNote = saveNote;
window.closePopup = closePopup;

// Initialize performance monitoring
if (window.performance && window.performance.mark) {
    window.performance.mark('ford-pm-dashboard-loaded');
}

console.log('üöó Ford PM Schedule Dashboard v3.0 - PIN Protection Ready! üöó');
